Для автоматизации процесса функционального тестирования в системе SAPFOR используется [CTest](https://cmake.org/cmake/help/latest/manual/ctest.1.html#id13), входящий в состав CMake и инструмент для автоматизации выполнения задача [PTS](https://github.com/zoocide/pts), написанный на языке программирования Perl. Чтобы включить тесты в процесс сборки системы, необходимо активировать опцию CMake `BUILD_TESTING` и задать путь до скрипта `pts.pl` в переменной `PTS_EXECUTABLE`. После этого в состав собираемых проектов в Microsoft Visual Studio будет включен проект `RUN_TEST`, сборка которого запустит все доступные в системе тестовые наборы. В случае использования инструмента `make` запустить тестирование можно выполнив команду `make test` в каталоге сборки.

Для автоматизированного запуска тестовых наборов необходимо:

- установить CMake версии достаточной для сборки проектов системы SAPFOR;
- установить Perl вместе с модулями `File::chdir`, `Text::Diff`, `Graph`, `Graph::Reader::Dot`;
- загрузить PTS из репозитория на [GitHub](https://github.com/zoocide/pts);
- настроить переменные CMake `BUILD_TESTION` и `PTS_EXECUTABLE` при конфигурировании сборки системы SAPFOR.

## Установка необходимых модулей Perl

Для запуска тестовых наборов может потребоваться дополнительная установка модулей `Perl`. Если какие-либо из требуемых модулей не доступны, будет выдано сообщение об ошибке, например, на Ubuntu 18.04 такое сообщение имеет вид:

```bash
Can't locate File/chdir.pm in @INC (you may need to install the File::chdir module)
```

В тексте сообщения указывается название отсутствующего модуля, в данном случае это `File::chdir`.

Установить все требуемые модули можно с помощью менеджера пакетов Perl `cpan`, выполнив команду:

```bash
cpan File::chdir Text::Diff Graph Graph::Reader::Dot
```

**Замечание.** При первом запуске `cpan` может предложить выполнить конфигурирование, необходимое для дальнейшей работы. Обычно данное конфигурирование может быть выполнено автоматически и в соответствующем запросе достаточно ответить `yes` и следовать дальнейшим инструкциям.

## Структура тестовых наборов

Каждый тестовый набор оформлен в виде нескольких отдельных проектов, отличающихся префиксом в названии, которые могут быть собраны отдельно для тестирования выбранной функциональности:

- `Test...` - отвечает за выполнение всех тестов из набора;
- `Init...` - отвечает за инициализацию всех тестов из набора, в этом случае будут заново созданы все эталонные результаты для тестового набора, используемые для проверки успешного прохождения тестов;
- `Fail...` - отвечает за выполнение всех тестов, для которых известно, что они не могут быть выполнены корректно

Например, на Linux системах, для тестирования прохода анализатора TSAR, отвечающего за определение циклов, представленных в канонической форме, можно выполнить команду:

```bash
make TestClangCanonicalLoop
```

В результате будет выведена информация о статусе выполнения каждого теста из набора:

```bash
[100%] Testing '-clang-canonical-loop' pass...
ok.............canonical_loop_1
ok.............canonical_loop_2
ok.............canonical_loop_3
ok.............canonical_loop_4
ok.............canonical_loop_5
ok.............canonical_loop_6
ok.............canonical_loop_7
ok.............canonical_loop_8
ok.............canonical_loop_9
ok.............canonical_loop_10
ok.............canonical_loop_11
ok.............canonical_loop_12
ok.............canonical_loop_13
ok.............canonical_loop_14
ok.............canonical_loop_15
ok.............canonical_loop_16
ok.............canonical_loop_17
ok.............canonical_loop_18
ok.............global_1
ok.............global_2
total time = 0.584

statistics:
num total    = 20
num complete = 20
num skipped  = 0
num failed   = 0
[100%] Built target TestClangCanonicalLoop
```

Кроме того, после установки системы SAPFOR совместно с системой тестирования PTS, в директории установки становится доступна утилита `sapfor-test`, позволяющая запускать как тестовые наборы, таки и отдельные тесты, а также просматривать результаты выполнения последнего запуска тестов.

## Добавление тестов в существующие тестовые наборы для TSAR

Тестовые наборы для статического анализатора TSAR расположены в директориях, вложенных в `tsar/test`. Директории, содержащие отдельные тесты, образуют отдельный тестовый набор.

### Структура теста

Каждому тесту из набора соответствует отдельная директория, включающая:

- входные данные, например, один или несколько файлов с исходным кодом;
- эталонные результаты, используемые для проверки корректности теста;
- один или несколько конфигурационных файлов, описывающих правила выполнения теста.

Отдельный тест включает как минимум один конфигурационный файл, описывающий правила выполнения теста. Так как каждый конфигурационный файл в системе PTS в общем случае задает отдельную независимую от других конфигурационных файлов последовательность действий, будем говорить, что в рамках одного теста конфигурационный файл порождает под-тест. И один тест в системе SAPFOR может содержать несколько под-тестов (например, запуск инструмента TSAR, компиляция преобразованной программы, запуск преобразованной программы).

Конфигурационный файл содержит определения переменных, часть из которых имеет зарезервированные имена и определяет правила выполнения теста, а другая часть может состоять из локально объявленных новых переменных, позволяющих упростить структуру конфигурационного файла. Во время обработки конфигурационного файла конструкции вида `$variable` будут заменены на значение переменной `variable`, которая может быть задана либо внутри конфигурационного файла до ее использования, либо может являться параметром запуска теста или иметь значение по умолчанию. Кроме того, конфигурационный файл может содержать комментарии, начинающиеся с префикса `#`. Чтобы продлить текущую строку на следующую строку, в конце строки можно добавить символ `\`.

Каждый конфигурационный файл в системе PTS имеет две зарезервированные переменные:

- `plugin` - задает модуль PTS, отвечающий за выполнение данного теста, все используемые модули определены в `tsar/utils/Plugins/` (в большинстве случаев используется модуль `TsarPlugin`);
- `name` - уникальные идентификатор теста в тестовом наборе, если данная переменная не задана явно в конфигурационном файле, то она устанавливается равной имени конфигурационного файла (без расширения), если в конфигурационном файле присваивается несколько значений данной переменной, то для именования теста используется результат последнего присваивания.

Кроме того плагин `TsarPlugin` резервирует для своего выполнения дополнительные переменные, которые должны быть заданы внутри конфигурационного файла, либо указываться при каждом запуске теста отдельно.

Рассмотрим переменные, которые обычно доступны извне конфигурационного файла и задаются отдельно для каждого запуска теста. Данные переменные в большинстве случаев задаются неявно при конфигурировании проектов SAPFOR перед их сборкой или внутри тестовой утилиты `sapfor-test`. Некоторые переменные устанавливает плагин PTS, отвечающий за запуск тестов:

- `clang` - путь до используемой версии компилятора Clang;
- `tsar` - путь до используемой версии инструмент TSAR;
- `include` - список дополнительных путей до заголовочных файлов, которые будут использованы при запуске инструмента TSAR;
- `dvm` - путь до скрипта `dvm`, отвечающего за компиляцию и запуск DVMH программ;
- `platform` - тип платформы на которой выполняется запуск;
- `exe_extension` - расширение используемое в имени исполняемых фалов на текущей платформе `$platform` (например `.exe` для ОС Windows);
- `run_prefix` - префикс предшествующий имени запускаемого исполняемого файла в зависимости от платформы (`./` - для OC Linux, пустой префикс для ОС Windows);
- `env::` - группа переменных, устанавливающая значения переменных окружения перед запуском теста, например `env::DVMH_NUM_CUDAS=1` установит значение переменной окружения `DVMH_NUM_CUDAS` для запуска DVMH программы, соответствующей данному тесту, на графическом ускорителе.

Каждый тест может выполняться в нескольких режимах, режим определяется значением переменной `$action`, задаваемой при его запуске:

- `init` - данный режим инициализирует тест, создавая эталонные результаты его запуска; уже существующие эталонные результаты будут заменены на новые;
- `check` - данный режим использует существующие эталонные результаты, чтобы проверить корректность выполнения теста (по умолчанию переменная `$action` получает значение `check`).

Во время выполнения теста происходит следующая последовательность действий:

1. В директории теста создается отдельная директория, если она еще не была создана, для хранения результатов выполнения теста. Чтобы явно задать имя рабочей директории для выполнения теста, можно использовать переменную `$work_dir`.
2. В директорию результатов копируются все файлы необходимые для выполнения теста: копируемые файлы должны быть заданы переменной `$copy`. Копирование выполняется с сохранением иерархии директорий. Если переменная не задана или в ней не указан ни один файл, то копирование выполняться не будет.
3. Выполняется переход в директорию результатов, которая становится рабочей и запуск всех последующих команд будет осуществляться из этой директории.
4. Выполняется команда выполнения теста, заданная переменной `$run`. Данную команду рекомендуется формировать независимым от платформы образом, чтобы запуск тестов был возможен на произвольной платформе. Для этой цели доступны дополнительные переменные, имеющие платформа зависимые значения, такие как `$run_prefix` и `$exe_extension`.
5. В зависимости от режима выполнение теста выполняется сравнение полученных результатов (режим `check`) с эталонными или их копирование в директорию с эталонными результатами (режим `init`). Чтобы задать имя директории с эталонноыми результатами можно использовать переменную `$sample_dir`, имеющую значение `sample` по умолчанию. Например, можно создать директорию, имя которой зависит от используемой платформы для запуска тестов (`sample_dir=sample_$platform`). Сравниваемые (копируемые) результаты (файлы) должны быть указаны в одной из следующих переменных внутри конфигурационного файла:

    - `sample` - список имен сравниваемых (копируемых) файлов; данная переменная используется в том случае, если имена эталонного файла и соответствующего файла, порождаемого результатом запуска теста, совпадают;
    - `sample_map` - список пар имен сравниваемых (копируемых) файлов; каждая пара содержит имя одного из файлов, порождаемого результатом запуска теста, и имя соответствующего эталонного файла. Имя файла с результатом указывается относительно директории с результатами, а имя файла эталона относительно `$samlple_dir`.

Таким образом основными переменными, описывающими правила выполнения под-теста являются `$copy`, `$run`, `$sample`, `$sample_map`, `$sample_dir`, `$work_dir`.

### Пример теста

В качестве примера рассмотрим тест `dvmh_sm_6` из набора `tsar/test/transform/dvmh_sm`. Данный тест отвечает за проверку корректности автоматического распараллеливания С программ на системы с общей памятью в модели DVMH.

Данный тест расположен в директории `dvmh_sm_6` и имеет следующую структуру:

- `main.c` - исходная последовательная программа,
- `include/main.h` - заголовочный файл в поддиректории `include` с объявлением глобальных переменных,
- `tsar.conf` - конфигурационный файл для генерации параллельной DVMH версии программы инструментом TSAR;
- `compile.conf` - конфигурационный файл для компиляции генерируемой DVMH-программы;
- `run.conf` - конфигурационный файл для запуска скомпилированной DVMH-программы;
- `seq.conf` - конфигурационный файл для компиляции и запуска последовательной программы;
- `sample` - директория с эталонными результатами выполнения теста, которая содержит:

  - `main.c` - параллельная DVMH-программа;
  - `include/main.h` - заголовочный файл в поддиректории `include`;
  - `output.txt` - вывод на стандартный поток вывода и стандартный поток ошибок, генерируемый инструментом TSAR в процессе распараллеливания программы;
  - `compile.txt` - вывод на стандартный поток вывода и стандартный поток ошибок, генерируемые компилятором DVMH-программ;
  - `run.txt` - эталонный результат выполнения программы (последовательной или параллельной).

Конфигурационный файл `tsar.conf` имеет вид, приведенный ниже.

```bash
plugin = TsarPlugin
sources = main.c
copy = $sources include/main.h
sample = main.c include/main.h output.txt
options = -clang-struct-replacement
run = "$tsar $sources $options >output.txt 2>&1"
```

В данном файле для удобства дополнительно определены две локальные переменные `$sources` и `$options`. Переменная `$sources` содержит все исполняемые файлы, относящиеся к данному тесту, в данном случае единственный файл `main.c`. Эти файлы будут переданы на вход инструменту TSAR, передавать на вход заголовочные файл, как и при использовании обычного компилятора, не требуется. Переменная `$options` задает опции компиляции.

Чтобы выполнить под-тест, можно воспользоваться вспомогательной утилитой, входящей в состав SAPFOR `sapfor-test`.

```bash
cd .../tsar/test/transform/dvmh_sm
sapfor-test dvmh_sm_6/tsar:action=init
sapfor-test dvmh_sm_6/tsar
```

Первый запуск выполняет инициализацию под-теста: режим выполнения задается в качестве параметра под-теста через переменную `$action`. Второй запуск происходит в режиме `check` (переменная `$action` получает данное значение по умолчанию).

В случае выполнения под-теста в режиме `init` на первом шаге в директорию с результатами запуска будут скопированы все исходные файлы, в том числе и заголовочные файлы, с сохранением иерархии директорий. Затем в этой директории будет выполнена команда `$run`, при этом путь до инструмента TSAR будет взят из переменной `$tsar`, которая будет задана утилитой `sapfor-test`. В результате в директории с результатами запуска исходный код последовательной программы будет модифицирован и будет сгенерирована параллельная версия программы с соответствующим изменением исходных файлов. Кроме того результаты запуска инструмента TSAR, выданные на стандартные потоки вывода и ошибок, будут записаны в файл `output.txt`, указанный в команде `$run` (`>output.txt 2>&1`). Затем параллельная версия программы, а также файл `output.txt` будут скопированы в директорию `sample`. В случае выполнения под-теста в режиме `check`, вместо копирования будет выполнено сравнение указанных файлов с соответствующими файлами в директории `sample`.

Важно иметь ввиду, что если какие-то исходные файлы не были модифицированы (например заголовочные файлы), то их рекомендуется копировать в директорию `sample` в любом случае (указывая их в переменной `$sample`). Это позволит избежать ситуации, когда при последующих изменения в инструменте TSAR эти файлы окажутся модифицируемыми, но запуск под-теста не позволит выявить изменение в поведении инструмента (если данные файлы отсутствуют в переменной `$sample`).

Если на разных платформах инструмент TSAR ведет себя по-разному, например, из-за особенностей построения внутреннего представления LLVM IR, используемого для анализа программ, то можно использовать переменную `sample_dir=sample_$platform`, чтобы создавать разные эталонные результаты на разных платформах. Стоит отметить, что перед выполнением под-теста в режиме проверки (`check`) на некоторой платформе необходимо убедится, что данный под-тест был инициализирован на данной платформе, то есть что существует соответствующая директория с эталонными результатами.

Конфигурационный файл `compile.conf`, отвечающий за компиляцию DVMH программ, имеет следующий вид.

```bash
plugin = TsarPlugin
sources = main.c
options = -o main$exe_extension
sample = compile.txt
run = "$dvm c $sources $options >compile.txt 2>&1"
```

В результате выполнения данного под-теста будут использованы исходные файлы DVMH-программы, уже расположенные в директории с результатами теста (после выполнения под-теста заданного файлом `tsar.conf`). Так как переменная `$copy` не задана копирование дополнительных файлов в эту директорию не выполняется. В результате выполнения данного под-теста будут созданы два файла: `compile.txt`, содержащий выдачу в стандартный поток вывода и ошибок, и исполняемый файл с платформо зависимым расширением, задаваемым опцией `$exe_extension`. При этом в качестве результата данного под-теста, который будет скопирован в директорию `sample` (для которого будет выполнено сравнение с соответствующим файлом из директории `sample`), рассматривается только файл `compile.txt`.

Конфигурационный файл `run.conf`, отвечающий за запуск скомпилированных DVMH программ, имеет следующий вид.

```bash
plugin = TsarPlugin
output = run_nt${env::DVMH_NUM_THREADS}_nc${env::DVMH_NUM_CUDAS}_g${grid}.txt
sample_map = $output run.txt
run = "$dvm run main${exe_extension} $grid >'$output' 2>&1"
```

В данном случае конфигурация запуска DVMH-программы определяется тем, как были заданы переменные окружения (группа `env::`), а также переменной `$gird`, которая является параметром данного под-теста и указывается при запуске под-теста. При этом имя файла (переменная `$output`) с результатами запуска зависит от используемой конфигурации запуска, в то время как эталонный результат запуска содержится в файле `run.txt`, одинаковом для всех запусков под-теста (переменная `$sample_map`).

Стоит отметить, что переменная `$gird` может содержать последовательность чисел, разделенных пробелами, поэтому в командах использующих имя файла, включающее данную переменную, необходимо использовать кавычки.

Запуск под-теста может иметь следующий вид:

```bash
cd .../tsar/test/transform/dvmh_sm
sapfor-test dvmh_sm_6/run:env::DVMH_NUM_THREADS=4,env::DVMH_NUM_CUDAS=0,grid="2 1"
```

Таже возможна упрощенная версия запуска данного под-теста:

```bash
sapfor-test dvm dvmh_sm_6/run:grid="2 1"
```

В данном случае `dvm` - это конфигурационный файл, аналогичный по структуре стандартному скрипту запуска DVMH компилятора. Шаблон данного файла можно найти в директории `tsar/test`, а также в директории `config` в директории, где установлена система SAPFOR. Для использования он может быть скопирован в директорию, из которой осуществляется вызов утилиты `sapfor-test`.

По умолчанию данный конфигурационный файл имеет следующий вид:

```bash
plugin = SetEnv
#grid = ''

[env]
#--------------- One can set launch options:
# dvmwait=0 # Wait for task completion
# DVMH_PPN='' # Number of processes per node
# DVMH_STACKSIZE='' # Stack size to set for the task
DVMH_NUM_THREADS='1' # Number of CPU threads per process
DVMH_NUM_CUDAS='0' # Number of GPUs per process
# DVMH_CPU_PERF='' # Performance of all cores of CPU per process
# DVMH_CUDAS_PERF='' # Performance of each GPU per device
# DVMH_NO_DIRECT_COPY=0 # Use standard cudaMemcpy functions instead of direct copying with GPU

# DVMH_SPECIALIZE_RTC=1 # Use specialization algorithm to reduce CUDA kernel's resources / or compile kernels during execution without changes

#--------------- Debugging options:
# DVMH_LOGLEVEL=1 # Levels of debugging: 1 - errors only, 2 - warning, 3 - info, 4 - debug, 5 - trace
# DVMH_LOGFILE='dvmh_%d.log' # Log file name for each process
# DVMH_COMPARE_DEBUG=0 # An alternative way to turn comparative debugging mode on
# dvmsave=0 # Save convertation results
# dvmshow=0 # Show commands executed by the DVM driver

#--------------- CUDA profiling options:
# CUDA_PROFILE=0 # Enable/disable CUDA profiling
# CUDA_PROFILE_CONFIG='cuda.conf' # File with GPU's metrics
# CUDA_PROFILE_LOG='cuda_profile.%d.%p' # Output file name for each process
# CUDA_PROFILE_CSV=1 # Set CSV output format
```

Все переменные из группы `[env]` будут установлены как переменные окружения пред выполнением под-теста, переменная `gird`, если задана, будет передана в качестве параметра запуска под-теста. При этом значения переменных заданных явно в качестве параметров запуска под-теста в командной строке имеют приоритет перед переменными заданными в данном конфигурационном файле.

Конфигурационный файл `seq.conf`, отвечающий за компиляцию и запуск последовательной версии программы, имеет следующий вид.

```bash
plugin = TsarPlugin
sources = main.c
copy = $sources include/main.h
work_dir = seq_res
sample = run.txt
options = -O3 -o seq$exe_extension
run = "$clang $sources $options && ${run_prefix}seq${exe_extension} >run.txt 2>&1"
```

В данном случае используется стандартный компилятор Clang для компиляции и запуска под-теста. Префикс ${run_prefix} позволяет отличить имя запускаемого файла от имени системной команды и в случае ОС Linux устанавливается `./`. Можно заметить, что эталонным результатом для данного под-теста является только результат запуска программы (переменная `$sample`).

Данный под-тест, как и под-тест `tsar` выполняет копирование исходных файлов программы в рабочую директорию, но, в отличие от под-теста `tsar`, не меняет содержимое испходных файлов программы. Чтобы не возникало конфликтов между запусками разных под-тестов, для данного теста явно указана рабочая директория (переменная `$work_dir`).

Конфигурационный файл `seq.conf` не является обязательным, если в качестве эталонного результата выполнения программы достаточно использовать результат запуска параллельной программ в какой-то конфигурации.

Таким образом, получить эталонный результат запуска и выполнить инициализацию всего теста можно следующими способами.

Если используется файл `seq.conf`:

```bash
cd .../tsar/test/transform/dvmh_sm
sapfor-test dvmh_sm_6/tsar:action=init
sapfor-test dvmh_sm_6/compile:action=init
sapfor-test dvmh_sm_6/seq:action=init
```

Если достаточно запуска параллельной программы в какой-то конфигурации:

```bash
cd .../tsar/test/transform/dvmh_sm
sapfor-test dvmh_sm_6/tsar:action=init
sapfor-test dvmh_sm_6/compile:action=init
sapfor-test dvmh_sm_6/run:action=init,env::DVMH_NUM_THREADS=1,env::DVMH_NUM_CUDAS=0
```

### Структура тестового набора

Кроме отдельных тестов каждый тестовый набор включает следующие файлы:

- `check` - содержит список всех тестов, которые должны быть запущены при выполнении тестового набора (соответствует проекту c префиксом `Test...`);
- `init` - содержит список тестов, для которых будут созданы новые эталонные результаты (соответствует проекту с префиксом `Init...`), каждый тест указывается в файле ввиде _`<идентификатор теста>:`_ `action=init` (возможно с дополнительным указанием параметров запуска теста);
- `fail` - содежит список тестов, для которых в данный момент поведение системы SAPFOR считается либо не корректным, либо предполагающим возможность дальнейшей оптимизации (соответствует проекту с префиксом `Fail...`).

Чтобы запустить на выполнения весь тестовый набор можно либо воспользоваться соответствующим проектом, создаваемым при сборке системы SAPFOR из исходных кодов, либо воспользоваться утилитой `sapfor-test`.

Например, запуск тестового набора `check` из директории `dvmh_sm` будет выглядеть следующим образом:

```bash
cd .../tsar/test/transform/dvmh_sm
sapfor-test check
```

Рассмотрим более подробно структуру тестового набора на примере тестового набора `check`, остальные тестовые наборы устроены аналогичным образом.

Тестовый набор представляет собой конфигурационный файл, описывающий параметры запуска каждого теста в наборе, а также правила параллельного и последовательного выполнения различных тестов/под-тестов набора. В тестовом наборе могут присутствовать области последовательного и параллельного выполнения тестов, которые могут быть вложены друг в друга. Чтобы ограничить область параллельного выполнения используются указания `parallel`, `end_parallel`. Чтобы ограничить область последовательного выполнения используются указания `seq`, `end_seq`, `end_seq_seq`. Спецификация `end_seq_seq` заканчивает одну последовательную область и начинает следующую. По умолчанию считается, что весь файл, соответствующий тестовому набору, является областью последовательного выполнения тестов. Границы областей и тесты должны быть указаны с новой строки.

```bash
parallel
  seq
    dvmh_sm/dvmh_sm_1/tsar
    dvmh_sm/dvmh_sm_1/compile
  end_seq_seq
    dvmh_sm/dvmh_sm_2/tsar
    dvmh_sm/dvmh_sm_2/compile
  end_seq
end_parallel

parallel
  dvmh_sm/dvmh_sm_1/run: env::DVMH_NUM_THREADS=1, env::DVMH_NUM_CUDAS=0
  dvmh_sm/dvmh_sm_1/run: env::DVMH_NUM_THREADS=2, env::DVMH_NUM_CUDAS=0
  dvmh_sm/dvmh_sm_2/run: env::DVMH_NUM_THREADS=1, env::DVMH_NUM_CUDAS=0
  dvmh_sm/dvmh_sm_2/run: env::DVMH_NUM_THREADS=2, env::DVMH_NUM_CUDAS=0
  seq
    dvmh_sm/dvmh_sm_1/run: env::DVMH_NUM_THREADS=0, env::DVMH_NUM_CUDAS=1
    dvmh_sm/dvmh_sm_2/run: env::DVMH_NUM_THREADS=0, env::DVMH_NUM_CUDAS=1
  end_seq
end_parallel
```

В данном конфигурационном наборе на верхнем уровне объявлены две параллельные области (построение параллельных версий программ с последующей их компиляцией и запуск параллельных версий программ). Выполнение групп тестов внутри каждой области выполняется параллельно, при этом сами области выполняются последовательно. Таким образом сначала выполняется построение параллельных версий и компиляция для всех тестов, а потом выполняются запуски полученных исполняемых файлов.

При этом первая параллельная область разбита на участки последовательного выполнения, таким образом, чтобы для каждого теста последовательно выполнялось распараллеливание с помощью инструмента TSAR и затем компиляция полученной параллельной программы. При этом разные тесты расположены в разных последовательных областях и обрабатываются параллельно.

Внутри второй параллельной области также выделена группа последовательно выполняющихся тестов: это тесты которые используют для своего выполнения графический ускоритель. Чтобы несколько тестов одновременно не занимали один и тот же ускоритель, тесты запускаются последовательно. При этом параллельно с этими запусками выполняются запуски на ядрах центрального процессора. Так как запуски на центральном процессоре расположены внутри параллельной области, то они выполняются параллельно независимо от того сколько физически доступно ядер. Это допустимо, так как данные тесты не являются тестами производительности, а проверяют корректность генерируемых программ.

Итак сначала параллельно выполняется две группы тестов:

- `dvmh_sm_1`, состоит из последовательной генерации параллельной программы (`tsar`) и ее компиляции (`compile`),
- `dvmh_sm_2`, состоит из последовательной генерации параллельной программы (`tsar`) и ее компиляции (`compile`).

Затем выполняется группы тестов отвечающих за запуск, при этом параллельно выполняется 2 запуска теста dvmh_sm_1/run и два запуска теста dvmh_sm_2/run на мультипроцессоре. Одновременно с этим выполняются тесты на графическом ускорителе, при этом в каждый момент времени на графическом ускорителе выполняется только один тест.

### Добавление тестов в набор

Таким образом, чтобы добавить новый тест в существующий тестовый набор необходимо:

1. Создать отдельную директорию для теста внутри директории тестового набора.
2. Внутри созданной директории добавить конфигурационные файлы (`tsar` - для тестирования только инструмента TSAR без последующего запуска тестовых программ, `compile` и `run` - для запуска параллельных DVMH-программ, `seq` - опционально, если требуется запуск исходной последовательной программы).
3. Добавить правила запуска теста в файлы `init` и `check` (или `fail`).
4. Внутри директории теста подготовить входные данные для запуска анализатора (исходный код программы).
5. Получить эталонные результаты, если тест относится ко множеству `check`.

## Просмотр и удаление результатов запуска теста

Чтобы посмотреть результаты запуска некоторого теста можно использовать команду `show` утилиты `sapfor-test`. Данная команда сравнивает результаты последнего запуска под-теста с результатами эталона и если они различаются, выводит разницу сравниваемых результатов. Если они совпадают или эталонный результат отсутствует, то результат запуска последнего под-теста выводится целиком. По умолчанию в результат выдачи данной команды попадают только файлы, указанные в переменной `$sample` или `$sample_map`. Чтобы также вывести исходные данные теста (переменная `$copy`) можно указать параметр `full` команды `show`.

Например, после того как в инструменте TSAR было реализовано добавление спецификации `tie` при построении DVMH-программ, результат сравнения последнего запуска под-теста `tsar` с эталонным результатом может выглядеть следующим образом:

```bash
sapfor-test show:full dvmh_sm_6/tsar

--- dvmh_sm_6.dvmhsm.c	Sun Jan 31 12:11:57 2021
+++ C:\Users\katae\workspace\apc\sapfor\analyzers\tsar\test\transform\dvmh_sm\dvmh_sm_6_YSh7\dvmh_sm_6.dvmhsm.c	Sun Jan 31 12:11:41 2021
@@ -7,17 +7,17 @@
 #pragma dvm actual(A, S)
 #pragma dvm region in(A, S)out(A, S)
   {
-#pragma dvm parallel([I][J][K]) tie(A[I][J][K])
+#pragma dvm parallel([I][J][K])
     for (int I = 0; I < N; ++I)
       for (int J = 0; J < N; ++J)
         for (int K = 0; K < 2; ++K)
           A[I][J][K] = I + J + K;
-#pragma dvm parallel([I][J][K]) tie(A[I][J][K]) across(A [1:0] [1:0] [0:0])
+#pragma dvm parallel([I][J][K]) across(A [1:0] [1:0] [0:0])
     for (int I = 1; I < N; ++I)
       for (int J = 1; J < N; ++J)
         for (int K = 0; K < 2; ++K)
           A[I][J][K] = A[I - 1][J][K] + A[I][J - 1][K] + A[I][J][K];
-#pragma dvm parallel([I][J][K]) tie(A[I][J][K]) reduction(sum(S))
+#pragma dvm parallel([I][J][K]) reduction(sum(S))
     for (int I = 0; I < N; ++I)
       for (int J = 0; J < N; ++J)
         for (int K = 0; K < 2; ++K)
```

Чтобы удалить результаты последнего запуска под-теста можно воспользоваться командой `clean` утилиты `sapfor_test`:

```bash
sapfor_test clean dvmh_sm_6/tsar
```

## Создание нового тестового набора

Чтобы создать новый тестовый набор необходимо:

1. Создать новую директорию, хранения всех тестов из набора. Директория должна быть расположена где-то в поддереве директорий с корнем в `tsar/test`.
2. На пути из директории `tsar/test` до созданной директории добавить файлы `CMakeLists.txt` (при отсутствии), содержащие команды `add_subdirectory(...)` для вложенных директорий.
3. Внутри директории тестового набора создать файлы `init` и `check` (`fail` - при необходимости).
4. Внутри директории тестового набора создать файл `CMakeLists.txt` добавляющий данную директорию в список тестовых наборов.

Файл `CMakeLists.txt` внутри директории c тестами из набора должен иметь вид:

```cmake
include(tsar-testing)
tsar_test(TARGET <test-set-name> PASSNAME "<pass-name>")
```

В данном случае _`<test-set-name>`_ задает имя тестового набора, _`<pass-name`>_ задает имя тестируемого прохода анализатора TSAR.

### Пример

Если создаваемый тестовый набор проверяет один из проходов преобразований, то соответствующая ему директория, например, `replace`, может быть расположена в поддиректории `tsar/test/transform`. В этом случае на пути до `replace` должны быть созданы следующие файлы `CMakeLists.txt`:

```cmake
# CMakeLists.txt in 'tsar/test'
add_subdirectory(transform)

# CMakeLists.txt in 'tsar/test/transform'
add_subdirectory(replace)
```

Внутри директории `replace` должен быть создан файл `CMakeLists.txt`:


```cmake
tsar_test(TARGET ClangStructReplace PASSNAME "-clang-struct-replacement")
```

В результате при конфигурировании и генерации проектов SAPFOR с помощью CMake будут созданы три проекта для запуска тестов: `TestClangStructReplace`, `InitClangStructReplace`, `FailClangStructReplace`.

## Детали использования системы PTS

Система PTS реализована на языке Perl, при этом утилита `sapfor-test` представляет собой обертку вокруг основного скрипта запуска PTS `pts.pl`.

Ручной запуск скрипта `pts.pl` може выглядеть следующим образом:

```bash
perl <path-to-pts> -I <path-to-repo>/utils -T <path-to-repo>/test -T . setenv:tsar=<path-to-tsar>,platform=<platform-name>,... <test-name>/<config-name>:action=init,...
```

В данном случае:
- _`<path-to-pts>`_ - путь к скрипту `pts.pl`,
- _`<path-to-repo>`_ - путь до репозитория анализатора TSAR,
- _`<path-to-tsar>`_ - путь до исполняемого файла, запускающего TSAR (может быть просто `tsar`, если соответствующий путь доступен в переменной `$PATH`),
- _`<platform-name>`_ - название платформы, на которой выполняется запуск теста,
- _`<test-name>`_ - директория, соответствующая запускаемому тесту,
- _`<config-name`_ - название конфигурационного файла для выбранного теста (указывается без расширения `.conf`).

Опция `-I` указывает директорию, где расположены плагины, используемые для запуска отдельного теста. Плагин - это скрипт на языке Perl, который вызывается системой PTS для выполнения теста, плагин выбирается в соответствии со значением переменной `$plugin` внутри конфигурационного файла для теста.

Опция `-T` указывает директорию, где будет выполняться поиск конфигурационных файлов. В данном примере основным выполняемым тестом является _`<test-name>/<config-name>`_, при этом предварительно выполняется задача, заданная конфигурационным файлом `setenv`, которая устанавливает внешние переменные, такие как `tsar`, `platform` и другие. При этом соответствующий конфигурационный файл `setenv.conf` расположен в директории _`<path-to-repo/test>`. После имени конфигурационного файла может следовать `:` с последующей инициализацией дополнительных переменных.
